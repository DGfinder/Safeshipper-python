# shipments/serializers.py
from rest_framework import serializers
from .models import Shipment, ConsignmentItem, ShipmentStatus

class ConsignmentItemSerializer(serializers.ModelSerializer):
    class Meta:
        model = ConsignmentItem
        fields = [
            'id',
            'shipment', # Included for explicitness, but often handled by nested context
            'description',
            'quantity',
            'weight_kg',
            'length_cm',
            'width_cm',
            'height_cm',
            'is_dangerous_good',
            'un_number',
            'proper_shipping_name',
            'hazard_class',
            'packing_group',
            'created_at',
            'updated_at',
        ]
        read_only_fields = ['id', 'created_at', 'updated_at']
        # If 'shipment' is always set by the parent ShipmentSerializer,
        # you might make it read_only=True here or exclude it if it's only for response.
        # For now, allowing it to be potentially writable if an item is created/updated standalone.

    def validate_weight_kg(self, value):
        if value is not None and value > 5000: # Example limit
            raise serializers.ValidationError("Weight per item must not exceed 5000 kg.")
        if value is not None and value < 0:
             raise serializers.ValidationError("Weight must be a positive value.")
        return value

    def validate_un_number(self, value):
        # Model's clean method already handles some of this, but serializer validation is good for API clarity.
        # This validation runs before model.clean() if called from serializer.save().
        if self.initial_data.get('is_dangerous_good') and not value:
            raise serializers.ValidationError("UN Number is required for dangerous goods.")
        if value and not value.upper().startswith("UN"):
            raise serializers.ValidationError("UN Number must start with 'UN'.")
        return value.upper() if value else None
    
    def validate(self, data):
        """
        Object-level validation for dangerous goods fields.
        """
        is_dg = data.get('is_dangerous_good', getattr(self.instance, 'is_dangerous_good', False)) # Get current or new value

        if is_dg:
            if not data.get('un_number', getattr(self.instance, 'un_number', None)):
                raise serializers.ValidationError({"un_number": "UN Number is required for dangerous goods."})
            if not data.get('proper_shipping_name', getattr(self.instance, 'proper_shipping_name', None)):
                raise serializers.ValidationError({"proper_shipping_name": "Proper Shipping Name is required for dangerous goods."})
            if not data.get('hazard_class', getattr(self.instance, 'hazard_class', None)):
                raise serializers.ValidationError({"hazard_class": "Hazard Class is required for dangerous goods."})
            # Packing group validation could be added here if strictly required for all DG
        return data

class ShipmentSerializer(serializers.ModelSerializer):
    items = ConsignmentItemSerializer(many=True, required=False) # 'required=False' allows creating shipments without items initially
    status = serializers.ChoiceField(choices=ShipmentStatus.choices, required=False) # Ensure status uses choices

    class Meta:
        model = Shipment
        fields = [
            'id',
            'reference_number',
            'tracking_number',
            'origin_address',
            'destination_address',
            'assigned_depot',
            'status',
            'estimated_departure_date',
            'actual_departure_date',
            'estimated_arrival_date',
            'actual_arrival_date',
            'created_at',
            'updated_at',
            'items',
        ]
        read_only_fields = ['id', 'tracking_number', 'created_at', 'updated_at']

    def create(self, validated_data):
        items_data = validated_data.pop('items', [])
        # Tracking number is auto-generated by the model's save method.
        # Status defaults to PENDING if not provided.
        shipment = Shipment.objects.create(**validated_data)
        for item_data in items_data:
            # Remove shipment from item_data if present, as it's set below
            item_data.pop('shipment', None)
            ConsignmentItem.objects.create(shipment=shipment, **item_data)
        return shipment

    def update(self, instance, validated_data):
        items_data = validated_data.pop('items', None)

        # Update shipment fields directly
        for attr, value in validated_data.items():
            setattr(instance, attr, value)
        instance.save() # This will also trigger the model's save() method for tracking_number if it was somehow empty

        # Handle nested updates for items
        if items_data is not None: # Only modify items if 'items' data was provided in the request
            # Simple strategy: delete existing items and recreate.
            # For production, you might want a more sophisticated update (e.g., matching by ID).
            instance.items.all().delete() 
            for item_data in items_data:
                item_data.pop('shipment', None)
                ConsignmentItem.objects.create(shipment=instance, **item_data)
        
        return instance
